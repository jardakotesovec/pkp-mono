<?xml version="1.0" encoding="UTF-8"?>
<dataConfig>
  <dataSource name="http-post" type="ContentStreamDataSource" connectionTimeout="300000" readTimeout="400000" />
  <dataSource name="field" type="FieldReaderDataSource" />
  <dataSource name="file" type="BinURLDataSource" />
  
  <script><![CDATA[
    /**
     * Some fields collect content from various entities.
     * These fields have to be stored in document rather than
     * entity context. This function is a helper function to
     * deal with the intricacies of document-level fields.
     *
     * @param Context context
     * @param String fieldName
     * @param String textToAppend
     */
    function appendToDocField(context, fieldName, textToAppend) {
      var docFields = context.getSessionAttribute('docFields', context.SCOPE_DOC);
      if (docFields === null) {
        docFields = [];
      }
      if (docFields.indexOf(fieldName) === -1) {
        docFields.push(fieldName);
        context.setSessionAttribute('docFields', docFields, context.SCOPE_DOC);
        var fieldValue = textToAppend;
      } else {
        var fieldValue = context.getSessionAttribute(fieldName, context.SCOPE_DOC);
        fieldValue += ' ' + textToAppend;
      }
      context.setSessionAttribute(fieldName, fieldValue, context.SCOPE_DOC);
    }
    
    /**
     * Custom transformer for the article entitiy.
     *
     * @param Map row
     * @param Context context
     * @returns Map The transformed row.
     */
    function transformArticle(row, context) {
      // Make IDs unique across installations.
      var articleId = row.get('article_id');
      var journalId = row.get('journal_id');
      var instId = row.get('inst_id');
      row.put('article_id', instId + '-' + articleId);
      row.put('journal_id', instId + '-' + journalId);
      
      // Add localized fields.
      var locFields = ['title', 'abstract', 'discipline', 'subject', 'type', 'coverage'];
      var indexTermFields = ['discipline', 'subject', 'type', 'coverage'];
      for (var i=0, len=locFields.length; i<len; i++) {
        var valueList = 'etl_' + locFields[i] + 'List';
        var localeList = 'etl_' + locFields[i] + 'List_locales';

        var values = row.get(valueList);
        if (values == null) continue;
        var locales = row.get(localeList);
        for(var j=0, locs=values.size(); j<locs; j++) {
          var locale = String(locales.get(j));
          var value = String(values.get(j));
          row.put(locFields[i] + '_' + locale, value);
          // Add all fields to the spelling field.
          appendToDocField(context, 'default_spell', value);
          // Add all fields to the "all" field. 
          appendToDocField(context, 'all_' + locale, value);
          // Add index term fields to the "index_terms" field.
          if (indexTermFields.indexOf(locFields[i]) >= 0) {
            appendToDocField(context, 'index_terms_' + locale, value);
          }
        }

        row.remove(valueList);
        row.remove(localeList);
      }
      
      // Prepare the galley XML.
      var galleyXml = row.get('etl_galley_xml');
      if (galleyXml == null) galleyXml = '<?xml version="1.0" encoding="utf-8"?><galleyList />';
      row.put('etl_galley_xml', String(galleyXml));

      // Prepare the supp file XML.
      var suppFileXml = row.get('etl_suppFile_xml');
      if (suppFileXml == null) suppFileXml = '<?xml version="1.0" encoding="utf-8"?><suppFileList />';
      row.put('etl_suppFile_xml', String(suppFileXml));

      return row;
    }

    /**
     * Custom transformer for files (galleys and
     * supplementary files).
     *
     * @param Map row
     * @param Context context
     * @returns Map The transformed row.
     */
    function transformFile(row, context) {
      // Interpret MIME type.
      var mimetype = String(row.get('etl_file_mimetype'));

      switch(mimetype) {
        case 'application/pdf':
          row.put('etl_file_mimetype', 'pdf');
          break;

        case 'text/html':
          row.put('etl_file_mimetype', 'html');
          break;

        default:
          // Unsupported MIME type: do not index the galley.
          row.remove('etl_file_name');
          row.remove('etl_file_locale');
          row.remove('etl_file_mimetype');
          row.put('$skipRow', 'true');
      }
      return row;
    }

    /**
     * Custom transformer for full text.
     *
     * @param Map row
     * @param Context context
     * @returns Map The transformed row.
     */
    function transformFullText(row, context) {
      var entityName = context.getParentContext().getResolvedEntityAttribute('name');
      var locale = context.resolve(entityName + '.etl_file_locale');
      var mimetype = context.resolve(entityName + '.etl_file_mimetype');

      // Analyze unknown locales with a generic analyzer.
      if (locale == 'unknown') locale = 'txt';

      // Construct the dynamic field name.
      var fieldName = entityName + '_full_text_' + mimetype + '_' + locale;

      // Deal with multiple entries for the same mimetype/locale.
      var fullText = row.get(fieldName);
      if (fullText === null) {
        fullText = '';
      } else {
        fullText = String(fullText) + ' ';
      }
      var currentText = String(row.get('text'));
      fullText += currentText;
      row.put(fieldName, fullText);

      // Add full text to spellchecker dictionary.
      appendToDocField(context, 'default_spell', currentText);

      // Add full text to the "all" field.
      appendToDocField(context, 'all_' + locale, currentText);
          
      row.remove('text');
      return row;
    }
    
    /**
     * This function is a custom transformer that will
     * be called after all other transformers. We use it
     * to store document-level fields to the document.
     *
     * NB: This cannot be done in the other transformers
     * as only the first row.put() will have effect.
     *
     * @param Map row
     * @param Context context
     * @returns Map The transformed row.
     */
    function postProcessArticle(row, context) {
      var docFieldName, docFieldValue;
      var docFields = context.getSessionAttribute('docFields', context.SCOPE_DOC);
      
      var authors = context.resolve('article.authors_txt');
      for (var i=0, lenD=docFields.length; i<lenD; i++) {
        docFieldName = docFields[i];
        docFieldValue = context.getSessionAttribute(docFieldName, context.SCOPE_DOC);
        
        // Add authors to spell check and "all" fields.
        if (docFieldName == 'default_spell' || docFieldName.indexOf('all_') === 0) {
          for (var j=0, lenA=authors.size(); j<lenA; j++) {
            author = String(authors.get(j));
            docFieldValue += ' ' + author;
          }
        }
        
        row.put(docFieldName, docFieldValue);
      }
      return row;
    }    
  ]]></script>

  <document>
    <entity name="article"
            dataSource="http-post"
            processor="XPathEntityProcessor"
            forEach="/articleList/article"
            transformer="script:transformArticle,LogTransformer"
            logTemplate="Indexing article ${article.inst_id}-${article.journal_id}-${article.article_id}." logLevel="info"
            stream="false"
            onError="continue" >

      <!-- ID fields -->
      <field column="article_id" xpath="/articleList/article/@id" />
      <field column="journal_id" xpath="/articleList/article/@journalId" />
      <field column="inst_id" xpath="/articleList/article/@instId" />

      <!-- Authors -->
      <field column="authors_txt" xpath="/articleList/article/authorList/author" multiValued="true" />

      <!-- Titles -->
      <field column="etl_titleList" xpath="/articleList/article/titleList/title" multiValued="true" />
      <field column="etl_titleList_locales" xpath="/articleList/article/titleList/title/@locale" multiValued="true" />

      <!-- Abstracts -->
      <field column="etl_abstractList" xpath="/articleList/article/abstractList/abstract" multiValued="true" />
      <field column="etl_abstractList_locales" xpath="/articleList/article/abstractList/abstract/@locale" multiValued="true" />

      <!-- Disciplines -->
      <field column="etl_disciplineList" xpath="/articleList/article/disciplineList/discipline" multiValued="true" />
      <field column="etl_disciplineList_locales" xpath="/articleList/article/disciplineList/discipline/@locale" multiValued="true" />

      <!-- Subjects -->
      <field column="etl_subjectList" xpath="/articleList/article/subjectList/subject" multiValued="true" />
      <field column="etl_subjectList_locales" xpath="/articleList/article/subjectList/subject/@locale" multiValued="true" />

      <!-- Types -->
      <field column="etl_typeList" xpath="/articleList/article/typeList/type" multiValued="true" />
      <field column="etl_typeList_locales" xpath="/articleList/article/typeList/type/@locale" multiValued="true" />

      <!-- Coverage -->
      <field column="etl_coverageList" xpath="/articleList/article/coverageList/coverage" multiValued="true" />
      <field column="etl_coverageList_locales" xpath="/articleList/article/coverageList/coverage/@locale" multiValued="true" />

      <!-- Publication Date -->
      <field column="publication_date_dt" xpath="/articleList/article/publicationDate" multiValued="false" />

      <!-- Galleys -->
      <field column="etl_galley_xml" xpath="/articleList/article/galley-xml" multiValued="false" />
      <entity name="galley"
              dataSource="field"
              dataField="article.etl_galley_xml"
              processor="XPathEntityProcessor"
              forEach="/galleyList/galley"
              transformer="script:transformFile"
              stream="false"
              onError="continue" >

        <field column="etl_file_name" xpath="/galleyList/galley/@fileName" multiValued="false" />
        <field column="etl_file_locale" xpath="/galleyList/galley/@locale" multiValued="false" />
        <field column="etl_file_mimetype" xpath="/galleyList/galley/@mimetype" multiValued="false" />

        <entity name="galley_file"
                dataSource="file"
                processor="TikaEntityProcessor"
                url="${galley.etl_file_name}"
                transformer="script:transformFullText"
                format="text" >
          <field column="text" />
        </entity>
      </entity>

      <!-- Supplementary Files -->
      <field column="etl_suppFile_xml" xpath="/articleList/article/suppFile-xml" multiValued="false" default="" />
      <entity name="suppFile"
              dataSource="field"
              dataField="article.etl_suppFile_xml"
              processor="XPathEntityProcessor"
              forEach="/suppFileList/suppFile"
              transformer="script:transformFile"
              stream="false"
              onError="continue" >

        <field column="etl_file_name" xpath="/suppFileList/suppFile/@fileName" multiValued="false" />
        <field column="etl_file_locale" xpath="/suppFileList/suppFile/@locale" multiValued="false" />
        <field column="etl_file_mimetype" xpath="/suppFileList/suppFile/@mimetype" multiValued="false" />

        <entity name="suppFile_file"
                dataSource="file"
                processor="TikaEntityProcessor"
                url="${suppFile.etl_file_name}"
                transformer="script:transformFullText"
                format="text" >
          <field column="text" />
        </entity>
      </entity>
      
      <entity name="articlePostProcessing"
              dataSource="field"
              dataField="article.article_id"
              processor="PlainTextEntityProcessor"
              transformer="script:postProcessArticle" >
      </entity>
    </entity>
  </document>
</dataConfig>
